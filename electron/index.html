<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Spotwire Electron</title>
    <!-- Link to external CSS file -->
    <link rel="stylesheet" href="styles.css">
    <!-- React, ReactDOM, Babel -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/babel">
      const { useState, useEffect, createContext, useContext } = React;
      const { ipcRenderer } = window.require ? window.require('electron') : { ipcRenderer: null };

      /* --------------------- Downloads Context --------------------- */
      const DownloadsContext = createContext();

      function DownloadsProvider({ children }) {
        const [downloads, setDownloads] = useState([]);

        // Add a new download entry
        const addDownload = (download) => {
          setDownloads(prev => [...prev, download]);
        };

        // Update an existing download by id
        const updateDownload = (downloadId, updates) => {
          setDownloads(prev =>
            prev.map(dl => dl.downloadId === downloadId ? { ...dl, ...updates } : dl)
          );
        };

        return (
          <DownloadsContext.Provider value={{ downloads, addDownload, updateDownload }}>
            {children}
          </DownloadsContext.Provider>
        );
      }

      function useDownloads() {
        return useContext(DownloadsContext);
      }

      /* --------------------- Floating Downloads Panel --------------------- */
      function DownloadPanel({ onClose }) {
        const { downloads } = useDownloads();
        return (
          <div className="download-panel">
            <h3>Downloads</h3>
            <table>
              <thead>
                <tr>
                  <th>Track</th>
                  <th>Status</th>
                  <th>Started</th>
                  <th>Elapsed (s)</th>
                </tr>
              </thead>
              <tbody>
                {downloads.map(dl => (
                  <tr key={dl.downloadId}>
                    <td>{dl.trackName} - {dl.artist}</td>
                    <td>{dl.status}</td>
                    <td>{new Date(dl.startTime).toLocaleTimeString()}</td>
                    <td>{dl.elapsed ? dl.elapsed : '-'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
            <button className="button" onClick={onClose}>Close</button>
          </div>
        );
      }

      /* --------------------- Home Page --------------------- */
      function Home() {
        useEffect(() => {
          const token = localStorage.getItem('spotify_access_token');
          if (token) window.location.hash = '#profile';
        }, []);

        function handleLogin() {
          const clientId = process.env.SPOTIFY_CLIENT_ID || 'YOUR_SPOTIFY_CLIENT_ID';
          const redirectUri = process.env.SPOTIFY_REDIRECT_URI || 'spotwire://callback';
          const scope = [
            "ugc-image-upload",
            "user-read-playback-state",
            "user-modify-playback-state",
            "user-read-currently-playing",
            "streaming",
            "app-remote-control",
            "playlist-read-private",
            "playlist-read-collaborative",
            "playlist-modify-private",
            "playlist-modify-public",
            "user-follow-modify",
            "user-follow-read",
            "user-read-playback-position",
            "user-top-read",
            "user-read-recently-played",
            "user-library-modify",
            "user-library-read",
            "user-read-email",
            "user-read-private",
          ];
          const params = new URLSearchParams({
            client_id: clientId,
            response_type: "code",
            redirect_uri: redirectUri,
            scope: scope.join(" "),
          });
          const loginUrl = `https://accounts.spotify.com/authorize?${params.toString()}`;
          if (window.require) {
            const { shell } = window.require('electron');
            shell.openExternal(loginUrl);
          } else {
            window.open(loginUrl, '_blank');
          }
        }

        return (
          <div className="container">
            <h1 className="title">spotwire</h1>
            <button onClick={handleLogin} className="button">Log in with Spotify</button>
            <a href="#instructions" className="button">Instructions</a>
          </div>
        );
      }

      /* --------------------- Instructions Page --------------------- */
      function Instructions() {
        return (
          <div className="container">
            <h2 className="title">Instructions</h2>
            <p style={{ maxWidth: '600px', marginBottom: '1rem' }}>
              Here you can add instructions for your Electron app, or anything else you want.
            </p>
            <a href="#" className="button">Back Home</a>
          </div>
        );
      }

      /* --------------------- Profile Page --------------------- */
      function Profile() {
        const [playlists, setPlaylists] = useState([]);
        const [loading, setLoading] = useState(true);
        const [searchTerm, setSearchTerm] = useState("");
        const accessToken = localStorage.getItem('spotify_access_token');

        function handleTokenExpiration() {
          localStorage.removeItem('spotify_access_token');
          window.location.hash = '';
        }

        useEffect(() => {
          if (accessToken) {
            fetch('https://api.spotify.com/v1/me/playlists', {
              headers: { Authorization: `Bearer ${accessToken}` },
            })
              .then(res => {
                if (!res.ok) {
                  if (res.status === 401) handleTokenExpiration();
                  throw new Error('Failed to fetch playlists');
                }
                return res.json();
              })
              .then(data => {
                setPlaylists(data.items || []);
                setLoading(false);
              })
              .catch(err => {
                console.error('Error fetching playlists', err);
                setLoading(false);
              });
          }
        }, [accessToken]);

        const filteredPlaylists = playlists.filter(playlist =>
          playlist.name.toLowerCase().includes(searchTerm.toLowerCase())
        );

        function handlePlaylistClick(playlistId) {
          window.location.hash = `#playlist/${playlistId}`;
        }

        function handleSettingsClick() {
          window.location.hash = '#settings';
        }

        return (
          <div className="profile-container">
            <div className="profile-header">
              <h1 className="profile-title">your spotify profile</h1>
              <span className="settings-icon" title="Settings" onClick={handleSettingsClick}>⚙️</span>
            </div>
            <div className="search-container">
              <input
                type="text"
                className="search-input"
                placeholder="Search playlists..."
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
              />
            </div>
            {loading ? (
              <p>Loading playlists...</p>
            ) : filteredPlaylists.length > 0 ? (
              <div className="playlist-grid">
                {filteredPlaylists.map(playlist => {
                  const imageUrl =
                    playlist.images && playlist.images.length > 0
                      ? playlist.images[0].url
                      : 'https://via.placeholder.com/300?text=No+Image';
                  return (
                    <div
                      key={playlist.id}
                      className="playlist-card"
                      onClick={() => handlePlaylistClick(playlist.id)}
                      title="Click to view tracks"
                    >
                      <img src={imageUrl} alt={playlist.name} className="playlist-image" />
                      <div className="playlist-name">{playlist.name}</div>
                    </div>
                  );
                })}
              </div>
            ) : (
              <p>No playlists found.</p>
            )}
          </div>
        );
      }

      /* --------------------- Updated Playlist Detail with Search and Load More --------------------- */
      function PlaylistDetail({ playlistId }) {
        const [tracks, setTracks] = useState([]);
        const [nextPageUrl, setNextPageUrl] = useState(null);
        const [loading, setLoading] = useState(true);
        const [loadingMore, setLoadingMore] = useState(false);
        const [searchTerm, setSearchTerm] = useState("");
        const accessToken = localStorage.getItem('spotify_access_token');
        const { downloads, addDownload } = useDownloads();

        // Helper: determine if a track is currently downloading
        const isDownloading = (trackId) => {
          return downloads.some(dl => dl.trackId === trackId && (dl.status === "Started" || dl.status === "In Progress"));
        };

        function handleTokenExpiration() {
          localStorage.removeItem('spotify_access_token');
          window.location.hash = '';
        }

        // Function to fetch a page of tracks given a URL
        const fetchTracks = (url, append = false) => {
          fetch(url, {
            headers: { Authorization: `Bearer ${accessToken}` },
          })
            .then(res => {
              if (!res.ok) {
                if (res.status === 401) handleTokenExpiration();
                throw new Error('Failed to fetch tracks');
              }
              return res.json();
            })
            .then(data => {
              setTracks(prev => append ? [...prev, ...(data.items || [])] : (data.items || []));
              setNextPageUrl(data.next);
              setLoading(false);
              setLoadingMore(false);
            })
            .catch(err => {
              console.error('Error fetching tracks', err);
              setLoading(false);
              setLoadingMore(false);
            });
        };

        // Fetch initial page of tracks when the component mounts.
        useEffect(() => {
          if (accessToken && playlistId) {
            const initialUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
            fetchTracks(initialUrl);
          }
        }, [accessToken, playlistId]);

        // Handler for the Load More button.
        const loadMore = () => {
          if (nextPageUrl) {
            setLoadingMore(true);
            fetchTracks(nextPageUrl, true);
          }
        };

        // Handle download button click
        function handleDownload(track) {
          const defaultFolder = localStorage.getItem('default_downloads_folder');
          if (!defaultFolder) {
            alert("No default download folder set. Please set it in Settings.");
            return;
          }
          if (!track.external_urls || !track.external_urls.spotify) {
            alert("Track URL not available.");
            return;
          }
          // Generate a unique downloadId.
          const downloadId = `${track.id}-${Date.now()}`;
          const trackUrl = track.external_urls.spotify;
          // Add download entry to global state.
          addDownload({
            downloadId,
            trackId: track.id,
            trackName: track.name,
            artist: track.artists.map(a => a.name).join(', '),
            status: "Started",
            startTime: Date.now(),
            elapsed: null
          });
          // Send IPC message with downloadId.
          ipcRenderer.send('execute-download-command', { downloadId, trackUrl, defaultFolder });
        }

        // Filter tracks based on search term (matches track name or any artist name)
        const filteredTracks = tracks.filter(item => {
          const track = item.track;
          if (!track) return false;
          const lowerCaseQuery = searchTerm.toLowerCase();
          const trackNameMatches = track.name.toLowerCase().includes(lowerCaseQuery);
          const artistMatches = track.artists.some(artist =>
            artist.name.toLowerCase().includes(lowerCaseQuery)
          );
          return trackNameMatches || artistMatches;
        });

        return (
          <div className="profile-container">
            <div className="profile-header">
              <h1 className="profile-title">Playlist Tracks</h1>
              <span className="button" onClick={() => window.location.hash = '#profile'}>
                Back to Profile
              </span>
            </div>
            {/* Search bar for filtering tracks */}
            <div className="search-container" style={{ marginBottom: '1rem' }}>
              <input
                type="text"
                className="search-input"
                placeholder="Search tracks or artists..."
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
              />
            </div>
            {loading && tracks.length === 0 ? (
              <p>Loading tracks...</p>
            ) : filteredTracks.length > 0 ? (
              <>
                <table>
                  <thead>
                    <tr>
                      <th>Track Name</th>
                      <th>Artist</th>
                      <th>Album</th>
                      <th>Download</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredTracks.map((item, index) => {
                      const track = item.track;
                      if (!track) return null;
                      return (
                        <tr key={track.id || index}>
                          <td>{track.name}</td>
                          <td>{track.artists.map(artist => artist.name).join(', ')}</td>
                          <td>{track.album.name}</td>
                          <td>
                            {isDownloading(track.id) ? (
                              <button className="button" disabled>Downloading...</button>
                            ) : (
                              <button className="button" onClick={() => handleDownload(track)}>
                                Download
                              </button>
                            )}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
                {nextPageUrl && (
                  <div style={{ margin: '1rem', textAlign: 'center' }}>
                    <button className="button" onClick={loadMore} disabled={loadingMore}>
                      {loadingMore ? "Loading..." : "Load More"}
                    </button>
                  </div>
                )}
              </>
            ) : (
              <p>No tracks found for this playlist.</p>
            )}
          </div>
        );
      }

      /* --------------------- Settings --------------------- */
      function Settings() {
        const [folder, setFolder] = useState(localStorage.getItem('default_downloads_folder') || '');

        async function selectFolder() {
          if (!ipcRenderer) {
            console.error('IPC not available.');
            return;
          }
          try {
            const selectedFolder = await ipcRenderer.invoke('select-download-folder');
            if (selectedFolder) {
              localStorage.setItem('default_downloads_folder', selectedFolder);
              setFolder(selectedFolder);
            }
          } catch (err) {
            console.error('Error selecting folder:', err);
          }
        }

        function clearFolder() {
          localStorage.removeItem('default_downloads_folder');
          setFolder('');
        }

        return (
          <div className="container">
            <div className="settings-container">
              <div className="settings-header">
                <span className="button" onClick={() => window.location.hash = '#profile'}>← Back</span>
                <h1 className="settings-title">Settings</h1>
              </div>
              <div className="settings-section">
                <h2>Default Downloads Folder</h2>
                <p className="folder-path">{folder ? folder : "No folder selected."}</p>
                <button className="button" onClick={selectFolder}>Select Downloads Destination</button>
                {folder && <button className="button" onClick={clearFolder}>Clear Selection</button>}
                <p style={{ marginTop: '1rem', fontSize: '0.875rem' }}>
                  This folder will be used as the default destination for your downloads.
                </p>
              </div>
            </div>
          </div>
        );
      }

      /* --------------------- Floating Downloads Button --------------------- */
      function FloatingDownloadsButton({ onToggle }) {
        return (
          <button className="button floating-downloads-button" onClick={onToggle}>
            View Downloads
          </button>
        );
      }

      /* --------------------- Main App & Router --------------------- */
      function App() {
        const [page, setPage] = useState(window.location.hash);
        const [showDownloads, setShowDownloads] = useState(false);
        const { updateDownload } = useDownloads();

        useEffect(() => {
          const onHashChange = () => setPage(window.location.hash);
          window.addEventListener('hashchange', onHashChange);
          return () => window.removeEventListener('hashchange', onHashChange);
        }, []);

        // Listen for download results globally
        useEffect(() => {
          function handleDownloadResult(event, result) {
            const elapsed = ((Date.now() - result.startTime) / 1000).toFixed(2);
            updateDownload(result.downloadId, {
              status: result.success ? `Complete (${elapsed} s)` : `Failed: ${result.error}`,
              elapsed: elapsed
            });
          }
          ipcRenderer.on('download-command-result', handleDownloadResult);
          return () => {
            ipcRenderer.removeListener('download-command-result', handleDownloadResult);
          };
        }, [updateDownload]);

        let Component;
        if (page.startsWith("#playlist/")) {
          const parts = page.split("/");
          const playlistId = parts[1];
          Component = <PlaylistDetail playlistId={playlistId} />;
        } else {
          switch (page) {
            case '#profile':
              Component = <Profile />;
              break;
            case '#instructions':
              Component = <Instructions />;
              break;
            case '#settings':
              Component = <Settings />;
              break;
            default:
              Component = <Home />;
          }
        }

        return (
          <>
            {Component}
            <FloatingDownloadsButton onToggle={() => setShowDownloads(prev => !prev)} />
            {showDownloads && <DownloadPanel onClose={() => setShowDownloads(false)} />}
          </>
        );
      }

      /* --------------------- Render App with Provider --------------------- */
      ReactDOM.render(
        <DownloadsProvider>
          <App />
        </DownloadsProvider>,
        document.getElementById('app')
      );

      /* --------------------- Global IPC Listeners --------------------- */
      if (ipcRenderer) {
        ipcRenderer.on('access-token', (event, token) => {
          console.log('Received access token:', token);
          localStorage.setItem('spotify_access_token', token);
          window.location.hash = '#profile';
        });
      }
    </script>
  </body>
</html>

